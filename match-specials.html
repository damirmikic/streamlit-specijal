<!DOCTYPE html>
<html lang="sr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xtip Specijal</title>
    <link rel="icon" type="image/png" href="merkur.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes spin { to { transform: rotate(360deg); } }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div class="container mx-auto p-4 md:p-8 max-w-4xl">
        <header class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h1 class="text-3xl font-bold text-gray-800">Meč Specijal Generator</h1>
            <p id="matchNameHeader" class="text-gray-600 mt-2">Loading match details...</p>
        </header>

        <main class="bg-white rounded-lg shadow-md p-6">
            <div id="loader" class="flex justify-center items-center h-48">
                <div class="spinner"></div>
            </div>

            <div id="specialsContent" class="hidden">
                <div id="specialsList" class="space-y-3">
                    </div>
                
                 <div class="mt-8 pt-6 border-t border-gray-200">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-bold text-indigo-800">Pregled Specijala za CSV</h2>
                        <div class="flex space-x-2">
                            <button id="addCalculatedSpecialsButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-3 rounded-lg text-xs">
                                Dodaj Kalkulisane
                            </button>
                             <button id="addPrepackSpecialsButton" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-3 rounded-lg text-xs">
                                Dodaj PrePacks
                            </button>
                        </div>
                    </div>
                     <div id="csvPreviewContent" class="space-y-6">
                         </div>
                     <div class="mt-6 text-right">
                         <button id="generateCsvButton" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-300">
                             Generiši CSV za Meč Specijal
                         </button>
                     </div>
                </div>
            </div>
             <div id="errorContainer" class="hidden text-center text-red-500 p-4 bg-red-50 rounded-lg">
                </div>
        </main>
    </div>
    
    <div id="toast-container" class="fixed bottom-5 right-5 z-50"></div>


    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const loader = document.getElementById('loader');
            const specialsContent = document.getElementById('specialsContent');
            const errorContainer = document.getElementById('errorContainer');
            const matchNameHeader = document.getElementById('matchNameHeader');
            const specialsList = document.getElementById('specialsList');
            const csvPreviewContent = document.getElementById('csvPreviewContent');
            const generateCsvButton = document.getElementById('generateCsvButton');
            const addCalculatedSpecialsButton = document.getElementById('addCalculatedSpecialsButton');
            const addPrepackSpecialsButton = document.getElementById('addPrepackSpecialsButton');
            
            let allMarkets = [];
            let fetchedData = null;
            let specialsForPreview = [];

            function removeDiacritics(text) {
                 if (!text) return '';
                text = text.replace(/đ/g, 'dj').replace(/Đ/g, 'Dj');
                return text.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            }

            function roundOdds(oddsStr) {
                const odd = parseFloat(oddsStr);
                 if (isNaN(odd)) return ''; // Handle cases where input is not a number

                let roundedOdd;
                if (odd > 5) {
                    roundedOdd = Math.round(odd / 0.1) * 0.1;
                } else if (odd > 3.5) {
                     roundedOdd = Math.round(odd / 0.05) * 0.05;
                } else {
                     roundedOdd = odd; // Keep original precision if below 3.5
                }
                
                 // Ensure minimum odd is 1.01
                 roundedOdd = Math.max(1.01, roundedOdd); 
                 
                 return roundedOdd.toFixed(2);
            }
            
             function formatLine(lineValue) {
                if (lineValue === null || lineValue === undefined) return '';
                const lineNum = parseFloat(lineValue);
                 if (isNaN(lineNum)) return ''; 
                 
                 // Provera da li je .5
                 if (lineNum % 1 === 0.5) {
                     return Math.ceil(lineNum); // Zaokruži na sledeći ceo broj
                 }
                 return lineNum.toString(); // Vrati kao string ako nije .5
            }
            
            function translatePrepackLabel(label) {
                let originalLabel = label;
                
                // Prvo, opštiji prevodi koji sadrže druge
                label = label.replace(/Player's shots on target \(Settled using Opta data\)/gi, "Šutevi u okvir gola");
                label = label.replace(/Player's shots \(Settled using Opta data\)/gi, "Ukupno šuteva");
                label = label.replace(/Player's fouls conceded \(Settled using Opta data\)/gi, "Načinjenih faulova");
                label = label.replace(/To Score Or Assist \(Settled using Opta data\)/gi, "Gol ili asistencija");
                label = label.replace(/To score or get an assist/gi, "Gol ili asistencija");
                label = label.replace(/To Score or Assist/gi, "Gol ili asistencija");
                label = label.replace(/To Assist \(Settled using Opta data\)/gi, "Asistencija");
                label = label.replace(/To score at least 2 goals/gi, "Daje 2+ gola");
                label = label.replace(/To score at least 3 goals/gi, "Daje 3+ gola (Het-trik)");
                label = label.replace(/To score from a header/gi, "Daje gol glavom");
                label = label.replace(/To score from outside the penalty box/gi, "Daje gol izvan šesnaesterca");

                // Specifični prevodi
                label = label.replace(/Yes Both Teams To Score/gi, "GG");
                label = label.replace(/No Both Teams To Score/gi, "NG");
                label = label.replace(/Both Teams To Score/gi, "GG"); // Fallback
                label = label.replace(/Total Corners/gi, "ukupno kornera");
                label = label.replace(/Total Cards/gi, "ukupno kartona");
                label = label.replace(/Total Goals/gi, "ukupno golova");
                label = label.replace(/Most Corners/gi, "više kornera");
                label = label.replace(/Most Cards/gi, "više kartona");

                // Zatim specifični, kraći
                label = label.replace(/To Score/gi, "Daje gol");
                label = label.replace(/To Get a Card/gi, "Dobija karton");
                label = label.replace(/To Get a Red Card/gi, "Dobija crveni karton");
                
                // *** IZMENJENA LOGIKA ZA OVER/UNDER ***
                 label = label.replace(/Over\s+([\d.]+)/gi, (match, p1) => {
                    const lineNum = parseFloat(p1);
                    // Provera za .5 linije -> X+1 +
                    if (!isNaN(lineNum) && lineNum % 1 === 0.5) {
                        return `${Math.ceil(lineNum)}+`;
                    }
                    // Fallback za ostale Over slučajeve (ako postoje)
                    return `više ${p1}`; 
                });
                label = label.replace(/Under\s+([\d.]+)/gi, (match, p1) => {
                    const lineNum = parseFloat(p1);
                     // Provera za .5 linije -> 0-X
                    if (!isNaN(lineNum) && lineNum % 1 === 0.5) {
                        return `0-${Math.floor(lineNum)}`;
                    }
                     // Fallback za ostale Under slučajeve (ako postoje)
                    return `manje ${p1}`; 
                });
                // *** KRAJ IZMENJENE LOGIKE ***
                
                // Timovi
                label = label.replace(/Full Time (.+)/gi, "$1 pobeđuje");

                // Ukloni duple razmake koji mogu nastati
                return label.replace(/\s+/g, ' ').trim();
            }


            function logError(message) {
                loader.style.display = 'none';
                errorContainer.textContent = message;
                errorContainer.classList.remove('hidden');
            }

            function showToast(message, type = 'success') {
                const toastContainer = document.getElementById('toast-container');
                const toast = document.createElement('div');
                let bgColor = 'bg-green-500';
                if (type === 'error') bgColor = 'bg-red-500';
                if (type === 'info') bgColor = 'bg-blue-500';
                
                toast.className = `${bgColor} text-white text-sm font-bold px-4 py-3 rounded-lg shadow-md animate-pulse`;
                toast.textContent = message;
                
                toastContainer.appendChild(toast);
                
                setTimeout(() => {
                    toast.remove();
                }, 2500);
            }

            // 1. Get Event ID and Fetch Data
            const params = new URLSearchParams(window.location.search);
            const eventId = params.get('eventId');

            if (!eventId) {
                logError("Event ID nije pronađen. Molimo vas vratite se na prethodnu stranicu i izaberite meč.");
                return;
            }
            
            const storedData = sessionStorage.getItem(`event_${eventId}`);
            if (storedData) {
                fetchedData = JSON.parse(storedData);
            } else {
                 logError("Podaci o meču nisu pronađeni. Molimo vas da prvo učitate meč na glavnoj stranici.");
                return;
            }

            try {
                const eventName = fetchedData.events[0]?.name || "Nepoznat meč";
                matchNameHeader.textContent = `Specijali za meč: ${eventName}`;
                
                // Flatten all outcomes into a simple array for easier lookup
                fetchedData.betOffers.forEach(offer => {
                    offer.outcomes.forEach(outcome => {
                        allMarkets.push({
                            betOfferId: offer.id,
                            marketName: offer.criterion.label,
                            line: (outcome.line !== undefined && outcome.line !== null) ? (outcome.line / 1000) : null,
                            label: outcome.label,
                            odds: (outcome.odds / 1000)
                        });
                    });
                });
                
                calculateAndDisplaySpecials();

            } catch (error) {
                logError(`Greška pri obradi podataka: ${error.message}`);
                return;
            }

            // 2. Helper function to find a specific odd
             function getOdd(marketNameIdentifier, line, labelIdentifier) {
                const marketNameLower = marketNameIdentifier.toLowerCase();
                const labelLower = labelIdentifier.toLowerCase();
                 
                // Mape za prevod na osnovu korisničkih zahteva
                const marketTranslations = {
                    "total goals": "ukupno golova",
                    "total corners": "ukupno kornera",
                    "total cards": "ukupno kartona",
                    "both teams to score": "gg", // Mapira se na GG
                    "penalty kick awarded": "penalty kick awarded",
                    "red card given": "red card given",
                    "total shots on target (settled using opta data)": "total shots on target (settled using opta data)"
                };
                
                const labelTranslations = {
                    "over": "više", // Mapira se na više
                    "under": "manje", // Mapira se na manje
                    "yes": "yes",
                    "no": "no"
                };

                // Prioritet dajemo prevedenim nazivima ako postoje
                const translatedMarket = marketTranslations[marketNameLower] || marketNameLower;
                const translatedLabel = labelTranslations[labelLower] || labelLower;

                // Pokušaj da nađeš koristeći prevedene nazive
                 const exactMatchTranslated = allMarkets.find(m => 
                     m.marketName.toLowerCase() === translatedMarket &&
                     m.line === line &&
                     m.label.toLowerCase() === translatedLabel
                 );
                 if (exactMatchTranslated) return exactMatchTranslated.odds;

                // Ako nije nađeno, pokušaj sa originalnim engleskim nazivima
                const exactMatchRaw = allMarkets.find(m => 
                    m.marketName.toLowerCase() === marketNameLower &&
                    m.line === line &&
                    m.label.toLowerCase() === labelLower
                );
                if (exactMatchRaw) return exactMatchRaw.odds;
                
                // Looser match sa proverom za prevod i original
                const looserMatch = allMarkets.find(m => 
                    (m.marketName.toLowerCase().includes(translatedMarket) || m.marketName.toLowerCase().includes(marketNameLower)) &&
                    !m.marketName.toLowerCase().includes('1st half') &&
                    !m.marketName.toLowerCase().includes('2nd half') &&
                    !m.marketName.toLowerCase().includes('by team') &&
                     fetchedData.events[0]?.participants?.length === 2 && // Proveri da li postoje participants pre pristupa
                    !m.marketName.toLowerCase().includes(`by ${fetchedData.events[0].participants[0].name.toLowerCase()}`) &&
                    !m.marketName.toLowerCase().includes(`by ${fetchedData.events[0].participants[1].name.toLowerCase()}`) &&
                    m.line === line &&
                    (m.label.toLowerCase() === translatedLabel || m.label.toLowerCase() === labelLower)
                );

                return looserMatch ? looserMatch.odds : null;
            }

            // 3. Newton-Raphson method to find lambda (expected goals)
            function lambda_from_p_over(p_over, tol = 1e-8, maxiter = 50) {
                 if (p_over <= 0) return 0.1; // Handle edge case: probability cannot be zero or negative
                 if (p_over >= 1) return 20; // Handle edge case: probability cannot be 1 or more (arbitrarily large lambda)

                let lam = 2.0; // Initial guess
                for (let i = 0; i < maxiter; i++) {
                    const exp_neg_lam = Math.exp(-lam);
                     // Calculate f(lambda) = 1 - P(X <= 2) - p_over
                    const f = 1 - exp_neg_lam * (1 + lam + (lam * lam) / 2) - p_over;
                     // Calculate f'(lambda) = P(X = 2) = e^(-lambda) * lambda^2 / 2
                    const fp = exp_neg_lam * ((lam * lam) / 2);
                     
                     // Avoid division by zero or very small numbers
                    if (Math.abs(fp) < 1e-12) { 
                         // If derivative is near zero, try a small perturbation or stop
                         lam += (f > 0 ? -tol : tol); // Nudge lambda slightly
                         if (lam <= 0) lam = tol;
                         continue; // Try again with nudged lambda
                         // break; // Alternative: Stop iteration if derivative is too small
                     }
                    const step = f / fp;
                    lam -= step;
                     // Ensure lambda stays positive
                     if (lam <= 0) {
                         lam = tol; // Reset to a small positive value if it goes non-positive
                         // break; // Option: stop if lambda becomes non-positive
                     }
                    if (Math.abs(step) < tol) {
                        break;
                    }
                }
                 // Ensure final lambda is positive
                 return lam > 0 ? lam : 0.1;
            }
            
            // Function to rename specials based on lines (using 0-X and Y+ format)
            function renameSpecialWithLine(baseName, line, type = 'over') {
                 if (line === null || line === undefined) return baseName;
                 const lineNum = parseFloat(line);
                 if (isNaN(lineNum)) return baseName;

                 // Only change for .5 lines
                 if (lineNum % 1 === 0.5) { 
                     if (type === 'over') {
                         const boundary = Math.ceil(lineNum);
                         // Replace first number found (e.g., 9.5+, 9+) with boundary+
                         return baseName.replace(/(\d+(\.\d+)?\+?)/, `${boundary}+`); 
                     } else { // type === 'under'
                         const boundary = Math.floor(lineNum);
                          // Replace first number found (e.g., 2.5-, 3-) with 0-boundary
                         return baseName.replace(/(\d+(\.\d+)?\-?)/, `0-${boundary}`);
                     }
                 }
                 return baseName; // Vrati originalni naziv ako nije .5 linija
            }

            
            // 4. Define and Calculate Specials
            function calculateAndDisplaySpecials() {
                const q_over_2_5 = getOdd("Total Goals", 2.5, "over");
                const q_under_2_5 = getOdd("Total Goals", 2.5, "under");
                let lam = 2.7; // Default fallback lambda (expected goals)

                if (q_over_2_5 && q_under_2_5) {
                    const p_over_raw = 1.0 / q_over_2_5;
                    const p_under_raw = 1.0 / q_under_2_5;
                    const margin = p_over_raw + p_under_raw;
                     if (margin > 0 && p_over_raw <= margin) { // Ensure valid probabilities
                        const p_over = p_over_raw / margin; // Normalize to remove margin
                        lam = lambda_from_p_over(p_over);
                    } else {
                         logStatus(`Invalid odds for Total Goals 2.5: Over=${q_over_2_5}, Under=${q_under_2_5}. Using default lambda.`, true);
                     }
                } else {
                    logStatus("Could not find Total Goals 2.5 odds. Using default lambda.", true);
                }

                 // Original names might now be slightly different due to renaming logic later
                 let specialsToCalculate = [
                    { originalName: "ukupno kornera 9.5+ i GG", lineCorners: 9.5, lineGoals: null, components: [() => getOdd("Total Corners", 9.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] , reduceOdds: true },
                    { originalName: "ukupno šuteva u okvir 9.5+ i ukupno golova 2.5+", lineShots: 9.5, lineGoals: 2.5, components: [() => getOdd("Total Shots on Target (Settled using Opta data)", 9.5, "over"), () => getOdd("Total Goals", 2.5, "over")] },
                    { originalName: "ukupno šuteva u okvir 10.5+ i GG", lineShots: 10.5, lineGoals: null, components: [() => getOdd("Total Shots on Target (Settled using Opta data)", 10.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 14.5+ i ukupno golova 2.5+", lineCorners: 14.5, lineGoals: 2.5, components: [() => getOdd("Total Corners", 14.5, "over"), () => getOdd("Total Goals", 2.5, "over")] },
                    { originalName: "ukupno kornera 14.5+ i GG", lineCorners: 14.5, lineGoals: null, components: [() => getOdd("Total Corners", 14.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 9.5+ i ukupno golova 2.5+", lineCorners: 9.5, lineGoals: 2.5, components: [() => getOdd("Total Corners", 9.5, "over"), () => getOdd("Total Goals", 2.5, "over")], reduceOdds: true },
                    { originalName: "ukupno kornera 8.5+ i ukupno golova 2.5+ i ukupno kartona 3.5+", lineCorners: 8.5, lineGoals: 2.5, lineCards: 3.5, components: [() => getOdd("Total Corners", 8.5, "over"), () => getOdd("Total Goals", 2.5, "over"), () => getOdd("Total Cards", 3.5, "over")] },
                    { originalName: "ukupno golova 2.5+ i ukupno kartona 3.5+", lineGoals: 2.5, lineCards: 3.5, components: [() => getOdd("Total Goals", 2.5, "over"), () => getOdd("Total Cards", 3.5, "over")] },
                    { originalName: "ukupno golova 2.5+ i ukupno kornera 7.5+", lineGoals: 2.5, lineCorners: 7.5, components: [() => getOdd("Total Goals", 2.5, "over"), () => getOdd("Total Corners", 7.5, "over")] },
                    { originalName: "ukupno šuteva u okvir 8.5+ i GG", lineShots: 8.5, lineGoals: null, components: [() => getOdd("Total Shots on Target (Settled using Opta data)", 8.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 11.5+ i GG", lineCorners: 11.5, lineGoals: null, components: [() => getOdd("Total Corners", 11.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 8.5+ i ukupno kartona 2.5+ i GG", lineCorners: 8.5, lineCards: 2.5, lineGoals: null, components: [() => getOdd("Total Corners", 8.5, "over"), () => getOdd("Total Cards", 2.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 8.5+ i ukupno kartona 3.5+ i GG", lineCorners: 8.5, lineCards: 3.5, lineGoals: null, components: [() => getOdd("Total Corners", 8.5, "over"), () => getOdd("Total Cards", 3.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "ukupno kornera 7.5+ i GG", lineCorners: 7.5, lineGoals: null, components: [() => getOdd("Total Corners", 7.5, "over"), () => getOdd("Both Teams To Score", null, "yes")] },
                    { originalName: "Penal i crveni karton", components: [() => getOdd("Penalty Kick awarded", null, "yes"), () => getOdd("Red Card given", null, "yes")], multiplier: 0.8 },
                    { originalName: "Penal ili crveni karton", calculation: () => { 
                        const oddsPen = getOdd("Penalty Kick awarded", null, "yes");
                        const oddsRed = getOdd("Red Card given", null, "yes");
                        if (!oddsPen || !oddsRed) return null;
                        const pPen = 1 / oddsPen;
                        const pRed = 1 / oddsRed;
                        const pPenAndRed = (pPen * pRed) * 1.2; // Adjusted intersection probability
                        const pOr = pPen + pRed - pPenAndRed;
                        return (pOr > 0 && pOr <=1) ? 1 / pOr : null; 
                     }},
                    { originalName: "Izmena postize gol", calculation: () => { 
                        const lambda_sub = lam * 0.15;
                        const prob = 1 - Math.exp(-lambda_sub);
                        return prob > 0 ? 1 / prob : null;
                    }},
                    { originalName: "Gol glavom na mecu", calculation: () => { 
                        const lambda_header = lam * 0.17;
                        const prob = 1 - Math.exp(-lambda_header);
                         return prob > 0 ? 1 / prob : null;
                    }},
                    { originalName: "Gol izvan 16m", calculation: () => {
                         const lambda_outside = lam * 0.12;
                        const prob = 1 - Math.exp(-lambda_outside);
                         return prob > 0 ? 1 / prob : null;
                    }},
                    { originalName: "Gol iz slobodnog udarca", calculation: () => {
                         const lambda_fk = lam * 0.05;
                        const prob = 1 - Math.exp(-lambda_fk);
                         return prob > 0 ? 1 / prob : null;
                    }},
                ];

                // Rename specials based on lines BEFORE calculating odds
                specialsToCalculate = specialsToCalculate.map(s => {
                    let name = s.originalName;
                     // Prvo primeni prevod za linije
                     if (s.lineCorners !== undefined) name = renameSpecialWithLine(name, s.lineCorners, 'over');
                     if (s.lineGoals !== undefined) name = renameSpecialWithLine(name, s.lineGoals, 'over');
                     if (s.lineCards !== undefined) name = renameSpecialWithLine(name, s.lineCards, 'over');
                     if (s.lineShots !== undefined) name = renameSpecialWithLine(name, s.lineShots, 'over');
                     
                     // Zatim prevedi ostale delove ako nisu već prevedeni (npr. GG)
                     name = name.replace(/ukupno kornera [\d.]+\+/g, match => renameSpecialWithLine(match, parseFloat(match.match(/[\d.]+/)[0]), 'over'));
                     name = name.replace(/ukupno golova [\d.]+\+/g, match => renameSpecialWithLine(match, parseFloat(match.match(/[\d.]+/)[0]), 'over'));
                     name = name.replace(/ukupno kartona [\d.]+\+/g, match => renameSpecialWithLine(match, parseFloat(match.match(/[\d.]+/)[0]), 'over'));
                     name = name.replace(/ukupno šuteva u okvir [\d.]+\+/g, match => renameSpecialWithLine(match, parseFloat(match.match(/[\d.]+/)[0]), 'over'));

                    return { ...s, name: name.replace(/\s+/g, ' ').trim() }; // Add the final 'name' property and clean spaces
                });

                
                specialsList.innerHTML = '';
                
                // Prvo, prikaži izračunate specijale
                specialsToCalculate.forEach(special => {
                    let finalOdd = null;
                    try {
                        if (special.components) {
                            const odds = special.components.map(fn => fn());
                             // Proveri da li su sve komponente validne kvote (veće od 1)
                            if (odds.every(o => o !== null && o > 1)) { 
                                finalOdd = odds.reduce((acc, val) => acc * val, 1) * (special.multiplier || 1);
                                 // Reduce odds if specified
                                if (special.reduceOdds) {
                                    finalOdd *= 0.9;
                                }
                            } else {
                                 // Ako neka komponenta nedostaje ili je <= 1, loguj upozorenje
                                 // console.warn(`Nedostajuće ili nevalidne komponente za ${special.name}:`, odds);
                             }
                        } else if (special.calculation) {
                            finalOdd = special.calculation();
                        }
                    } catch (calcError) {
                         console.error(`Greška pri izračunavanju specijala ${special.name}: ${calcError}`);
                         finalOdd = null; // Osiguraj da je finalOdd null u slučaju greške
                     }


                    // Round AFTER potential reduction and ensure >= 1.01
                    if (finalOdd !== null && !isNaN(finalOdd)) {
                         finalOdd = parseFloat(roundOdds(String(finalOdd))); 
                    } else {
                        finalOdd = null; // Ensure it's null if calculation failed or resulted in NaN
                    }


                    const oddValue = (finalOdd !== null && finalOdd >= 1.01) ? finalOdd.toFixed(2) : ''; // Only set value if valid
                    const inputId = `odds-input-${special.originalName.replace(/[^a-zA-Z0-9]/g, '-')}`; // Use original name for stable ID

                    const div = document.createElement('div');
                    div.setAttribute('data-special-type', 'calculated'); // Mark as calculated
                    div.className = 'flex justify-between items-center p-3 border rounded-lg';
                    div.innerHTML = `
                        <span class="text-gray-800 flex-1">${special.name}</span>
                        <div class="flex items-center gap-3 w-auto md:w-1/3">
                            <input 
                                type="text" 
                                value="${oddValue}" 
                                class="odds-input w-24 p-1 border rounded text-center font-medium" 
                                placeholder="N/A" 
                                id="${inputId}"
                                ${!oddValue ? 'disabled' : ''} /* Disable input if no valid odd */
                            >
                            <button 
                                data-name="${special.name}" {/* Use final name for adding */}
                                data-input-id="${inputId}" 
                                class="add-special-btn bg-blue-500 text-white px-3 py-1 rounded-full hover:bg-blue-600 ${!oddValue ? 'opacity-50 cursor-not-allowed' : ''}"
                                ${!oddValue ? 'disabled' : ''} /* Disable button if no valid odd */
                            >+</button>
                        </div>
                    `;
                    specialsList.appendChild(div);
                });
                
                // Dodaj PrePacks
                if (fetchedData.prePacks && fetchedData.prePacks.length > 0) {
                    
                    const separator = document.createElement('div');
                    separator.className = 'pt-4 mt-4 border-t border-gray-200';
                    separator.innerHTML = '<h3 class="text-lg font-semibold text-gray-700 mb-2">Pre-Pack Specijali (Direktno iz API-ja)</h3>';
                    specialsList.appendChild(separator);

                    fetchedData.prePacks.forEach(pack => {
                        pack.prePackSelections.forEach((selection, index) => {
                            const odds = (selection.combinations[0].odds.decimal / 1000);
                             if (odds < 1.01 || odds > 40) return; 

                            const translatedLabels = selection.label.map(translatePrepackLabel);
                            const marketName = translatedLabels.join(' I ');
                            let finalOdd = parseFloat(roundOdds(String(odds)));
                            
                            const oddValue = (finalOdd >= 1.01) ? finalOdd.toFixed(2) : ''; 
                            const inputId = `odds-input-prepack-${selection.selectionId || index}`; 

                            const div = document.createElement('div');
                            div.setAttribute('data-special-type', 'prepack'); // Mark as prepack
                            div.className = 'flex justify-between items-center p-3 border rounded-lg bg-indigo-50'; 
                            div.innerHTML = `
                                <span class="text-gray-800 flex-1 text-sm">${marketName}</span>
                                <div class="flex items-center gap-3 w-auto md:w-1/3">
                                    <input 
                                        type="text" 
                                        value="${oddValue}" 
                                        class="odds-input w-24 p-1 border rounded text-center font-medium" 
                                        placeholder="N/A"
                                        id="${inputId}"
                                         ${!oddValue ? 'disabled' : ''} /* Disable input if no valid odd */
                                    >
                                    <button 
                                        data-name="${marketName}" 
                                        data-input-id="${inputId}" 
                                        class="add-special-btn bg-blue-500 text-white px-3 py-1 rounded-full hover:bg-blue-600 ${!oddValue ? 'opacity-50 cursor-not-allowed' : ''}"
                                         ${!oddValue ? 'disabled' : ''} /* Disable button if no valid odd */
                                    >+</button>
                                </div>
                            `;
                            specialsList.appendChild(div);
                        });
                    });
                }
                
                loader.style.display = 'none';
                specialsContent.classList.remove('hidden');
            }

            function renderPreview() {
                 const previewSectionContainer = csvPreviewContent.closest('div.mt-8.pt-6'); 
                if (specialsForPreview.length > 0) {
                    if (previewSectionContainer) previewSectionContainer.classList.remove('hidden');
                } else {
                     if (previewSectionContainer) previewSectionContainer.classList.add('hidden');
                }

                csvPreviewContent.innerHTML = '';
                specialsForPreview.forEach((special, index) => {
                     const div = document.createElement('div');
                     div.className = 'grid grid-cols-[1fr,auto,auto] gap-4 items-center p-2 border-b';
                     div.innerHTML = `
                        <input 
                            type="text" 
                            value="${special.name}" 
                            class="w-full p-1 border rounded" 
                            data-index="${index}"
                            data-field="name" 
                        >
                        <input 
                            type="text" 
                            value="${special.odds}" 
                            class="w-20 p-1 border rounded text-center" 
                            data-index="${index}"
                            data-field="odds"
                        >
                        <button 
                            class="remove-special-btn ml-4 text-red-500 font-bold" 
                            data-index="${index}"
                        >&times;</button>
                     `;
                     csvPreviewContent.appendChild(div);
                });
            }

            // Event Listeners
            specialsList.addEventListener('click', e => {
                if (e.target.classList.contains('add-special-btn')) {
                    const button = e.target;
                     if (button.disabled) return; 
                    
                    const { name, inputId } = button.dataset;
                    const oddsInput = document.getElementById(inputId);
                    const odds = oddsInput.value;

                    if (!odds || isNaN(parseFloat(odds)) || parseFloat(odds) < 1.01) {
                        showToast("Molimo unesite ispravnu kvotu (minimalno 1.01).", "error");
                        return;
                    }
                    
                     if (!specialsForPreview.some(s => s.name === name)) {
                         specialsForPreview.push({ name, odds: parseFloat(odds).toFixed(2) }); // Ensure odds are formatted
                         renderPreview();
                         showToast("Market dodat u CSV");
                     } else {
                         showToast("Market je već dodat u listu.", "info");
                     }
                }
            });
            
            function addSpecialsByType(type) {
                let addedCount = 0;
                const allSpecialElements = specialsList.querySelectorAll(`div[data-special-type="${type}"] .add-special-btn`);
                
                allSpecialElements.forEach(btn => {
                     if (btn.disabled) return; 
                    
                    const { name, inputId } = btn.dataset;
                    const oddsInput = document.getElementById(inputId);
                    let odds = oddsInput.value;

                    if (odds && !isNaN(parseFloat(odds)) && parseFloat(odds) >= 1.01 && !specialsForPreview.some(s => s.name === name)) {
                        odds = parseFloat(odds).toFixed(2); // Format odds on add
                        specialsForPreview.push({ name, odds });
                        addedCount++;
                    }
                });

                if (addedCount > 0) {
                    renderPreview();
                    showToast(`${addedCount} ${type === 'calculated' ? 'kalkulisanih' : 'PrePack'} marketa dodato u CSV.`);
                } else {
                     showToast(`Nema novih ${type === 'calculated' ? 'kalkulisanih' : 'PrePack'} marketa za dodavanje ili su već dodati.`, "info");
                }
            }

            addCalculatedSpecialsButton.addEventListener('click', () => addSpecialsByType('calculated'));
            addPrepackSpecialsButton.addEventListener('click', () => addSpecialsByType('prepack'));


            csvPreviewContent.addEventListener('click', e => {
                if (e.target.classList.contains('remove-special-btn')) {
                    const index = parseInt(e.target.dataset.index, 10);
                     if (index >= 0 && index < specialsForPreview.length) {
                        specialsForPreview.splice(index, 1);
                        renderPreview();
                    }
                }
            });
            
             csvPreviewContent.addEventListener('input', e => {
                if (e.target.tagName === 'INPUT') {
                    const index = parseInt(e.target.dataset.index, 10);
                    const field = e.target.dataset.field; // "name" or "odds"
                    if (index >= 0 && index < specialsForPreview.length && (field === 'name' || field === 'odds')) { 
                         specialsForPreview[index][field] = e.target.value;
                         // Optional: Re-format odds if changed
                         if (field === 'odds') {
                            const numOdds = parseFloat(e.target.value);
                             if (!isNaN(numOdds)) {
                                 // Maybe re-apply rounding? Or just keep user input? 
                                 // For now, keep user input directly.
                             }
                         }
                    }
                }
            });
            
            generateCsvButton.addEventListener('click', () => {
                 if (specialsForPreview.length === 0) return;

                const header = "Datum,Vreme,Sifra,Domacin,Gost,1,X,2,GR,U,O,Yes,No";
                let csvRows = [header];

                const eventInfo = fetchedData.events[0];
                 // Provera da li eventInfo postoji
                if (!eventInfo) {
                    logError("Nema informacija o događaju za generisanje CSV-a.", true);
                    return;
                }
                const matchDate = new Date(eventInfo.start);
                const datum = `${matchDate.getDate().toString().padStart(2, '0')}.${(matchDate.getMonth() + 1).toString().padStart(2, '0')}.${matchDate.getFullYear()}`;
                const vreme = `${matchDate.getHours().toString().padStart(2, '0')}:${matchDate.getMinutes().toString().padStart(2, '0')}`;
                
                csvRows.push('MATCH_NAME:Xtip Specijal');
                csvRows.push(`LEAGUE_NAME:${eventInfo.name || 'Nepoznata Liga'}`);
                
                specialsForPreview.forEach(special => {
                     const finalOdds = parseFloat(special.odds);
                     // Dodaj red samo ako je kvota validan broj veći ili jednak 1.01
                    if (!isNaN(finalOdds) && finalOdds >= 1.01) {
                         const row = [datum, vreme, '', special.name, 'DA', finalOdds.toFixed(2), '', '', '', '', '', '', ''];
                        csvRows.push(row.join(','));
                    } else {
                         console.warn(`Preskačem red za "${special.name}" zbog nevalidne kvote: ${special.odds}`);
                         showToast(`Kvota za "${special.name}" (${special.odds}) nije validna i biće preskočena u CSV-u.`, "error");
                     }
                });
                
                // Proveri da li je ostao samo header + MATCH_NAME + LEAGUE_NAME
                if (csvRows.length <= 3) {
                     showToast("Nema validnih specijala za izvoz u CSV.", "error");
                     return;
                 }


                const csvContent = csvRows.join('\n');
                const matchName = removeDiacritics(eventInfo.name || 'nepoznat_mec').replace(/ /g, '_').replace(/vs/ig, ''); // Koristi 'ig' za case-insensitive zamenu
                const fileName = `mec_specijal_${matchName}.csv`;
                
                const BOM = "\uFEFF";
                const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                 URL.revokeObjectURL(url); // Oslobodi memoriju
            });

        });
    </script>
</body>
</html>
